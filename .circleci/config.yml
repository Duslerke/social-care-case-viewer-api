version: 2.1

executors:
  docker-ubu:
    docker:
      - image: cimg/base:2021.04

jobs:
  build-and-test:
    machine:
      image: ubuntu-2004:202010-01
    steps:
      - checkout
      - run:
          name: mach
          command: uname -a
      - run:
          name: dependencies
          command: sudo apt-get update && sudo apt-get install -y pcregrep
      - run:
          name: Scrape
          command: |
            echo "Start!"
            set +e
            echo "https://dr03nduqxh.execute-api.eu-west-2.amazonaws.com/staging/" > ./baseURL.txt
            echo "Post File!"
            # Should be parameterized when in the pipeline
            projectDirectory='.'
            # No need to search the project root or tests project
            apiProjectDirectory=$( find $projectDirectory -mindepth 1 -type d -iname '*Api' )
            echo "Before functions!"
            function find_files_using_interface {
                local interface=$1
                local startDirectory=$2
                # [ -z "$interface" ] && { echo "Interface is empty!"; return 1; }
                grep -rlwE $startDirectory -e "public class \w+ : $interface"
            }

            function find_files_using_class {
                local class=$1
                local startDirectory=$2
                # Not convinced on the value of exit codes yet
                grep -rlwE $startDirectory -e "public class $class : \w+"
            }

            # There should be only one file that contains the dependency method
            # from the call
            function find_files_by_dependency_type {
                local dataType=$1
                local startDirectory=$2
                local dependencyFile=$(find_files_using_interface $dataType $startDirectory)
                if [ -z "$dependencyFile" ]
                then
                    dependencyFile=$(find_files_using_class $dataType $startDirectory)
                fi
                echo $dependencyFile
            }

            # Creating a partially applied function (like in Haskell)
            function find_dependency_file_name_in_api_directory {
                local dataType=$1
                find_files_by_dependency_type "$dataType" "$apiProjectDirectory"
            }

            # Should also probs look for Npgsql import - it might be smth else like MySQL
            function isPostgreContextFile {
                local filePath=$1
                grep -woPq '(?<=public class )\w+(?= \: DbContext)' "$filePath"

                [[ $? -eq 0 ]] && echo 0 || echo 1
            }

            function getPostgreContextName {
                local filePath=$1
                grep -woP '(?<=public class )\w+(?= \: DbContext)' "$filePath"
            }

            # Could also search "IMongoDatabase", which is part of Mongo Driver I assume.
            function isMongoContextFile {
                local filePath=$1

                grep -woPq 'public class [^I\s]\w+(?= : \w+)' "$filePath"
                local isNotInterface=$?

                grep -woPq 'public IMongoCollection<BsonDocument> \w+ { get\; set\; }' "$filePath"
                local containsMongoCollection=$?

                [[ $isNotInterface -eq 0 && $containsMongoCollection -eq 0 ]] && echo 0 || echo 1
            }

            function getMongoContextName {
                local filePath=$1
                grep -woP '(?<=public class )\w+(?= : \w+)' "$filePath"
            }

            # If the name is empty, consider error?
            # It shouldn't be possible.
            function determineDBContextName {
                local filePath=$1

                [[ $(isPostgreContextFile $filePath) -eq 0 ]] && getPostgreContextName $filePath && return 0
                [[ $(isMongoContextFile $filePath) -eq 0 ]] && getMongoContextName $filePath && return 0
                # TODO: Add DynamoDB indentifier (if possible)
            }

            function determineDBContextType {
                local filePath=$1

                [[ $(isPostgreContextFile $filePath) -eq 0 ]] && echo 'PostgreSQL' && return 0
                [[ $(isMongoContextFile $filePath) -eq 0 ]] && echo 'MongoDB' && return 0
                # TODO: Add DynamoDB indentifier (if possible)
            }

            function methodBlock {
                local methodNamePattern=$1

                if [ -z "$methodNamePattern" ]
                then
                    methodNamePattern='\w+'
                fi

                echo "\n\s+(?>(?:public|static|private) )+(?:async )?\S+\?? $methodNamePattern\([^\(\)]*\)(\s+)\{[\s\S]+?\1\}"
            }

            methodSignature='\n\s+(?>(?:public|static|private) )+(?:async )?\S+\?? \w+\([^\(\)]*\)'

            function fileMethodNamesPattern {
                local fileName=$1
                pcregrep -M "$methodSignature" $fileName | \
                grep -oP '\b\w+(?=\s*\([^\(\)]*\))(?![^[]+\])' | \
                tr '\n' '|' | \
                sed -E 's/\|$//g;s/(.+)/\(\?:\1\)/'
            }

            function fileMethodCallsWithinMethodPattern {
                local fileName=$1
                echo "(?<![\w>?] )(?<!\.)\b$(fileMethodNamesPattern $fileName)(?=\((?:[^\(\)]+)?\))"
            }

            function getFileScopeMethodCallsWithinMethod {
                local methodName=$1
                local filePath=$2
                pcregrep -M "$(methodBlock $methodName)" $filePath | \
                grep -oP "$(fileMethodCallsWithinMethodPattern $filePath)"
            }

            dependencyVariablePattern='private(?: readonly)? \K\w+ \K\w+(?=;)'

            function append_to_endpoint_info {
                local oldEndpointInfo=$1
                local methodName=$2
                echo $oldEndpointInfo | perl -pe "s/(?<=CallChain: )([\w ,]+)(?=!)/\1, $methodName/g"
            }

            function get_field_from_accumulator {
                local fieldName=$1
                local accumulatorVal=$2
                echo "$accumulatorVal" | grep -oP "(?<=$fieldName: )[^!]+(?=!)"
            }

            function get_controller_route {
                local controllerFilePath=$1
                pcregrep -oM '\[Route\(\"[^"]+\"\)\][\S\s]+public class \w+ : Controller' $controllerFilePath |
                grep -oP '\[Route\(\"\K[^"]+(?=\"\)\])'
            }

            endpointMetadata='(?:\[[^\[\]]+\]\s+)+public (?:async )?\S+ \w+\b(?! : Controller\n)'
            methodBlock='\([^\(\)]*\)(\s+)\{[\s\S]+?\1\}'
            echo "Before main function!"
            
            function scanAndFollowDependencies {
                local scannedFile=$1
                local accumulator=$2
                
                echo "Acc: $accumulator"

                if [ -z "$scannedFile" ]
                then
                    # temporary silly resolution for the base problem case like validator, etc.
                    echo "Dead End Case!"
                    return 1
                fi
                
                echo "Pre-deps array"
                
                local dependencyVariablesSearchPattern=$(grep -oP -e "$dependencyVariablePattern" $scannedFile | \
                    tr '\n' '|' | sed -E 's/\|$//g' )

                echo "Pre-dep lookup"

                eval "declare -A dependencyTypeLookup=($(\
                    grep -oP "private(?: readonly)? \K\w+ \w+(?=\;)" $scannedFile | \
                    sed -E 's/(\w+)\s(\w+)/\[\2\]=\1/g' | \
                    tr '\n' ' '))"

                echo "pre-dep count"

                local dependencyCount=${#dependencyTypeLookup[@]}

                (grep -wq ": Controller" $scannedFile)
                local isController=$?
                
                echo "Post isController"

                if [[ $isController -ne 1 ]]; then
                    echo "Is Controller"
                    local targetMethod=$( echo $accumulator | grep -oP '(?<=Name: )\w+' )
                    local targetMethodBlock=$(pcregrep -M "$(methodBlock $targetMethod)" $scannedFile)
                else
                    echo "Not Controller"
                    local targetMethod=$(echo $accumulator | grep -oP '(?<= )\w+(?=!\>)')
                    local targetMethodBlock=$(pcregrep -M "$(methodBlock $targetMethod)" $scannedFile)
                fi
                
                echo "Pre-If end of the road"

                if [[ -z "$targetMethodBlock" || $dependencyCount -eq 0 ]]
                then
                    echo "DB Context"
                    local dbType=$(determineDBContextType $scannedFile)
                    local dbName=$(determineDBContextName $scannedFile)

                    [[ -z "$dbType" && -z "$dbName" ]] && return 1

                    # TODO: Extract this into a function
                    local eName=$(get_field_from_accumulator Name "$accumulator")
                    local eRoute=$(get_field_from_accumulator Route "$accumulator")
                    local eType=$(get_field_from_accumulator Type "$accumulator")
                    echo "<DbName: $dbName! DbType: $dbType! Name: $eName! Type: $eType! Route: $eRoute!>"
                    return 0
                fi
                    echo "Not DB Context"
                    getFileScopeMethodCallsWithinMethod $targetMethod $scannedFile | while read localCall ; do {
                        scanAndFollowDependencies "$scannedFile" "$(append_to_endpoint_info "$accumulator" "$localCall")"
                    } ; done
                    
                    echo "Pre- for each dependency recurse"
                    
                    echo "$targetMethodBlock" | \
                    grep -oP "(?>(?:$dependencyVariablesSearchPattern)\.\w+)" | while read dependencyCall ; do {                
                        dependencyMethod=$(echo "$dependencyCall" | grep -oP '\.\K\w+')    
                        dependencyVarName=$(echo "$dependencyCall" | grep -oP '\w+(?=\.)')
                        dependencyFileName=$(find_dependency_file_name_in_api_directory "${dependencyTypeLookup[$dependencyVarName]}")
                        echo "Post nodbc, each-dep recurse variables"
                        scanAndFollowDependencies "$dependencyFileName" "$(append_to_endpoint_info "$accumulator" "$dependencyMethod")"
                    } ; done
            }
            echo "Find Controllers!"
            controllersList=$(find "$apiProjectDirectory/V1/Controllers" -mindepth 1)
            echo "Before loop!"
            for controllerFile in $controllersList
            do
                echo "$controllerFile"
                controllerRoute=$(get_controller_route "$controllerFile" | sed -E 's/\//\\\//g')
                echo "$controllerRoute"
                pcregrep -M "$endpointMetadata" $controllerFile | \
                perl -0777 -pe "s/(?:(?:\[Http(\w+)\]|\[Route\(\"([^\"]+)\"\)\]|(?:\[[^\[\]]+\]))\s+)+public (?:async )?\S+ (\w+)/<Route: $controllerRoute\/\2! Type: \1! Name: \3! CallChain: \3!>/gm; s/R: .+?\K\/\/(?=[^!]+!)/\//gm" | \
                grep -oP '<[^<>]+>' | while read endpointInfo ; do {
                    scanAndFollowDependencies "$controllerFile" "$endpointInfo"
                } ; done
                echo "Loop Done!"
            done
            echo "End!"

workflows:
  wf-name:
    jobs:
      - build-and-test
